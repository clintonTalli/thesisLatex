%I) Algorithm Complexity
%	a) Algorithm
%		procedure of calculations
%		has a running time
%		utilizes resources
%		goal: have an algorithm that runs quickly and utilizes a small amount of resources
%	b) Qualitative Analysis of Algorithms
%		worst case running time
%		brute force
%		efficiency
%	c) Spaces of Algorithms
%		polynomial time
%		PSPACE
%		NP
%		P
%		NP-Complete
\section{Algorithm Complexity}
\textit{Algorithms} are a list of instructions executed with a given input.  
%When an algorithm executes its procedures, its efficiency can be measured in terms of units of resources such as memory and time. %it takes to complete the procedure of calculations.  
The efficiency of an algorithm can be measured in terms of the amount of resources it uses such as time, memory, and power.
Ideally, a desirable algorithm would primarily have a small run time and secondarily utilize a small amount of resources.

%ELABORATE ON RAM DESCRIPTION
The time and space used by an algorithm is measured with units defined by a model of computation.
The actual running time of an algorithm depend on a variety of factors for example: the processor, the hardware, the temperature, etc.
Mathematical models of computation have been developed to measure running time of algorithms independent of the machine it runs on.
One of the oldest and most popular models is the random access machine (RAM) model.
RAM measures the unit of space in the number of words used where each word can store an arbitrary integer.
In the real RAM, each word can store an arbitrary real number.
The units of time is measured in the number of arithmetic operations and number of memory accesses (read or write). 

% \subsection{Qualitative Analysis of Algorithms  }
%Determining the time and space that algorithms use determine their efficiency. 
The \textit{running time} of an algorithm on a given input, is the time it takes to terminate.% an algorithm with the input. 
The \textit{worst-case} running time is the largest running time over all inputs of a given size $N$.  
It is a function of $N$, it is usually monotonically increasing function since larger inputs tend to take more time to process.
The key parameter of the efficiency of an algorithm is the growth rate of its worst case running time in terms of $N$.
An algorithm is said to be \textit{efficient} if the time needed to perform the list of instructions can be determined from a polynomial. 
Devising an efficient algorithm for a given problem is often a difficult task.% however one can typically solve a problem by trying all possi
%if it achieves qualitatively better worst-case performance, at an analytical level, than brute force search.% \cite{kleinberg2006algorithm}.
% \subsection{Categorization of Algorithms}
%For combinatorial problems, as the number of inputs of the problem grows, the solution space tends to grow exponentially.  
% For decision problems, 
% n general, as problems grow, it is desirable to minimize 
% Formally, we quantify running time with Big O notation.

The growth rate of running times are typically compared upto constant vectors.
Let $f$ and $g$ be defined on some subset of $\bbR$.  
$f(x) = O\left(g(x)\right)$ if and only if there exists a constant $M$ and $x_0$ such that $$\left\vert g(x)\right\vert \leq M \left\vert f(x) \right\vert$$
for all $x \geq x_0$



% \subsubsection{P and NP}
% There are various types of running times; the running time that we will focus on in this thesis is 
% polynomial running time ($\P$), nondeterministic polynomial running time ($\NP$), and 
% non-deterministic polynomial complete running time ($\NP$ complete).

%An algorithm has a \textit{polynomial running time} if there is a polynomial function $p$ such that for every input string $s$, the algorithm terminantes on $s$ in at most $O\left( p \left( \left\vert s \right\vert\right)\right)$ steps.  

%To categorize problems \cite{kleinberg2006algorithm}, we ask the following:
\subsection{Complexity Classes}
Problems can be categorized by their running times.
Each algorithm computes a function $f(I)$ on an input $I$, however many different algorithms can compute the same function.
Algorithms are differentiated by their running times but the function is characterized by the fastest algorithm that can compute it.
A problem can be formulated as follows, given input $I$ find $f(I)$.

Problems can be categorized into complexity classes based on the fastest algorithms that solve them.
The class of problems that can be solved in polynomial running time is called the \textit{polynomial time} class, $\P$.

A second property of problems is whether its solution can be verified efficiently.  
This property is independent of whether it can be solved efficiently.  
$B$ is said to be an \textit{efficient certifier} for a problem $X$  if the following properties hold:
\begin{itemize}
\item[(i)] $B$ is a polynomial-time algorithm that takes two inputs $s$ and $t$.
\item[(ii)] There exists a polynomial function $p$ such that for every string $s$, we have $s \in X$ if and only if there exists a string $t$ such that $\vert t \vert \leq p\left( \vert s \vert \right)$ and $B(s,t) = \text{'yes'}$.
\end{itemize}

The class of problems which have an efficient certifier is said to be the \textit{nondeterministic polynomial time} class, $\NP$. 
We continue with the definitions for $\NP$-hard and $\NP$-complete.
A problem is $\NP$-hard if every problem in $\NP$ can be reduced to it in polynomial time.
A \textit{polynomial time reduction} is when arbitrary instances of problem $Y$ be solved using a polynomial number of standard computational steps, plus a polynomial number of calls to a black box that solves problem $X$, i.e. $Y$ is reduced in polynomial time to $X$.
A problem is $\NP$-complete if it $\NP$ and $\NP$-hard, i.e. $\NP$-complete = $\NP \cap \NP$-hard.


 %and what an efficient certification is.  
%This facilitates the reader for the definitions and illustrate complexity better. 
 
% \subsection{Reduction}



% \subsection{Independent Sets and Vertex Covers}
% To illustrate what a reduction is, we cover an example of independent sets and vertex covers.  
% Recall the definitions of an independent set and vertex cover.
% Given a graph $G = (V,E)$, a set of vertices $S \subset V$ is \textit{independent} if no two vertices in $S$ are joined by an edge. 
% A \textit{vertex cover} of a graph $G = (V,E)$  is a set of vertices $S \subset V$ if every edge $e \in E$, has at least one end corresponding in $S$.

% \begin{thm}\label{thm:ch1-complexity-1}
% Let $G = (V,E)$ be a graph.  
% Then $S$ is an independent set if and only if its complement $V-S$ is a vertex cover.
% \end{thm}
% \begin{proof}
% If $S$ is an independent set. Then for any pair of vertices in $S$, the pair are not joined by an edge if and only if for any $v_1, v_2 \in S$, $e = \left( v_1, v_2 \right) \not \in E$.  
% We have two cases.  
% The first case is if $v \in S$, then any vertex $u \in V$ that forms an edge $e = (v,u) \in E$ must reside in $V-S$. 
% The second case is if there is an edge which no pair of vertices is in $S$, then both vertices are in $V-S$.  
% Both cases together imply that every edge has at least one end corresponding in $V-S$. 

% If $V-S$ is a vertex cover.  
% Every edge $e \in E$ has at least one vertex in $V-S$.  
% The two possible cases, the first case is that the second vertex is in $V-S$, and the second case is that the second vertex is in $S$.  The first case would yield $S = \emptyset$.  
% The second case implies that the edge $e \in E$ has exactly one vertex in $V-S$ and exactly one vertex in $S$.  
% $V-S$ is a vertex cover would disallow $S$ to have a pair of vertices to form an edge in the graph.
% \end{proof}
% Theorem \ref{thm:ch1-complexity-1} allows for problem reductions for independent set and vertex cover problems.

% % \subsubsection{Reduction of the Independent Set and Vertex Cover Problem}
% There are two problems for the independent set: an optimization problem and a decision problem.
% \begin{prob}[Optimization of an Independent Set in $G$]\label{prob:maxindependentset}
% Given a graph $G$, what is the largest independent set in $G$?
% \end{prob}
% \begin{prob}[Decision of an Independent Set of Size $k$]\label{prob:kindependentset}
% Given a graph $G$ and a number $k$, does $G$ contain an independent set of size at least $k$?
% \end{prob}
% % [NEEDS TO PROVE REDUCIBILITY IN THIS PARAGRAPH BELOW]
% % An algorithm that solves the optimization problem automatically solves the decision problem of the 
% % independent set.  An algorithm that solves the decision problem for all size $k$ solves the 
% % optimization problem where the decision is "yes" for the largest value of $k$.  This establishes a 
% % reduction of the optimization problem to the decision problem and vice versa. 
% % [NEEDS TO PROVE REDUCIBILITY IN THIS PARAGRAPH ABOVE]
% Consider an algorithm $A$ that determines whether $G$ contains an independent set of size $k$.  
% By querying $A$ with $k=1,2,...,\vert V \vert$, one can find a maximal independent set size in $G$.
% Conversely, if we have an algorithm $B$ that can the largest independent set in $S \subset V$, then we know the order of $S$, $\vert S\vert$.  
% Any subset of $S$ is also an independent set; any subset $W \subset V$ such that $\vert S \vert < \vert W \vert \leq \vert V \vert$ is not independent.  
% While $B$ is an algorithm that solves Problem \ref{prob:maxindependentset}, $B$ can be leveraged to solve Problem \ref{prob:kindependentset}.  
% Likewise, $A$ solve Problem \ref{prob:kindependentset} but can be leveraged to solve Problem \ref{prob:maxindependentset}.


%FROM COMPLEXITY, USE THE PAPER TO SHOW THAT OUR DECISION PROBLEMS ARE HARD.


% Other classes of problems are $\NP-\text{complete}$ and 
% $\NP-\text{hard}$.  $\NP-\text{complete}$ is a class of decision problems.  A problem $\mathcal{C}$ 
% is said to be $\NP-\text{complete}$ if $\mathcal{C} \in \NP$ and every problem $\mathcal{D} \in 
% \NP$ 
% is reducible to $\mathcal{C}$ in polynomial time.  $\NP-\text{hard}$ is a class of problems that 
% are 
% at least as hard as $\NP-\text{complete}$ problems.
