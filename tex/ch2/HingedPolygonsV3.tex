\section{Logic Engines Represented as Polygonal Linkages}   
We can modify the mechanical structure of the logic engine to form a polygonal linkage.  

\begin{figure}[!htbp]
\begin{center}
\includegraphics{graphics/HingedLogicEngineSmall.pdf}
\caption{A logic engine realized as a polygonal linkage.}\label{fig:HingedLogicEngineSmall.pdf}
\end{center}
\end{figure}
Suppose we are given an instance of a boolean formula with $m$ clauses and $n$ variables in 3-CNF form.  
The polygonal linkage logic engine that corresponds to this boolean formula has the following 
dimensions:
$$\begin{array}{|l|c|c|c|}%TRY TO ADD SHADING COLUMN TO TABLE AND GRAPHIC:
 \hline
 \text{Component} & \text{Height} & \text{Width} & \text{Quantity}\\\hline
 \text{Shaft Subcomponent} & 1 & 3 & n\\\hline
 \text{Armature Subcomponent} & 2 & 1 & 2\cdot m\\\hline
 \text{Flag} & 1 & 1.5 & -\\\hline
 \text{Large Frame Subcomponent} & 2\cdot m & - & 4\\\hline
\end{array}$$
Each shaft subcomponent corresponds to an armature and its subcomponents. The shaft subcomponents 
have two orientations.  The armature subcomponents have two orientations.  The armature subcomponents may have rectangular flags. Flagging arragement 
indicates the relationship of the boolean literal's existence within a clause.   An armature 
subcomponent is flagged according to the following rules:
\begin{enumerate}
 \item If the literal $x_j$ is found in clause $C_k$, then the armature subcomponent $l_{j,k}$ is 
unflagged.
 \item If the literal $\bar{x}_j$ is found in clause $C_k$, then the armature 
subcomponent $\bar{l}_{j,k}$ is unflagged.
\end{enumerate}
The left and right frame subcomponents are static and rigid.
\begin{figure}[!htbp]
\begin{center}
\includegraphics{graphics/HingedLogicEngineSmallEnumerated.pdf}
\caption{A polygonal linkage logic engine that corresponds to the boolean formula $\Phi = C_1 \cap C_2 \cap C_3$.}\label{fig:HingedLogicEngineSmallEnumerated.pdf}
\end{center}
\end{figure}

\begin{thm}\label{thm:chp2-HingedPolygons-1}
 Given an instance of a $NAE3SAT$,  it is a ``yes'' instance if and only if the 
corresponding polygonal linkage logic engine has a collision-free configuration.  
\end{thm}
\begin{proof}
Suppose we have an instance of a $NAE3SAT$ that is a ``yes'' instance. This implies that there is a 
truth assignment such that each clause contains a true and a false literal. Now consider the polygonal linkage logic 
engine corresponding to this instance. We now 
show that it has a collision free configuration.

For variables that are true, configure the armatures such that the flags corresponding to the 
non-negated literals reside above the 
shaft and the flags that correspond to the negated literals reside below this shaft.  For variables 
that are false, configure the 
armatures in the opposite orientation.  Each clause corresponds to a pair of rows in 
the polygonal linkage logic engine, one row for non-negated literals and one for negated literals.  Because the 
$NAE3SAT$ is a yes instance, every row contains at least one unflagged armature.  
By Lemma \ref{lem:logicEngine1}, every row  has a collision-free configuration.

Suppose we have an instance of a $NAE3SAT$ such that the corresponding polygonal linkage logic engine has a 
collision-free configuration. By Lemma \ref{lem:logicEngine1} every row at least one unflagged 
armature.  The $k^{th}$ clause is represented by the $k^{th}$ rows above and below the shaft. If the 
literal $x_j$ is found in clause $C_k$, then the armature is unflagged in that row. If the literal 
$\bar{x}_j$ is found in clause $C_k$, then $\bar{l}_{j,k}$ is unflagged.  All flags 
corresponding to negated literals reside below the shaft and flags corresponding to non-negated 
literals reside above the shaft.  All together we have that every clause has a true literal and a 
false literal.  Thus, we have a 'yes' instance of the $NAE3SAT$.
\end{proof}